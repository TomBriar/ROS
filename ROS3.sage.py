

# This file was *autogenerated* from the file ROS3.sage
from sage.all_cmdline import *   # import sage library

_sage_const_115792089237316195423570985008687907852837564279074904382605163141518161494337 = Integer(115792089237316195423570985008687907852837564279074904382605163141518161494337); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16); _sage_const_1024 = Integer(1024)
import hashlib
import struct
from datetime import datetime
import math
import json


Prime = _sage_const_115792089237316195423570985008687907852837564279074904382605163141518161494337 
IntPrime = Integers(Prime)
lambdaParameter = math.ceil((math.log(Prime) / math.log(_sage_const_2 )));
print(lambdaParameter)

w = _sage_const_3  #2^w = 7

L = _sage_const_5 

k1 = _sage_const_2 **w-_sage_const_1  # 7
k2 = max(_sage_const_0 , math.ceil(lambdaParameter - (w + _sage_const_1 ) * L)) # 0
print(k1)
print(k2)
print(k1+k2)

l = k1+k2
R = PolynomialRing(GF(Prime),l,"x")
Y = R.gens()
X = []
P = []
for x in Y:
	X.append(x)
	P.append(x)

def coeffs(p):
	result = []
	zero = []
	for x in X:
		result.append(p.coefficient(x))
		zero.append(_sage_const_0 )
	result.append(p(zero))
	return result

def encode(p):
	p = coeffs(p)
	result = b""
	for i in range(_sage_const_0 , len(p)):
		hexval = str(int(p[i]))
		result = result + hexval.encode()
	return result

def hash(x, aux = 'aux321'):
	return IntPrime(R(int(hashlib.sha256(bytes(str(aux), "ascii")+bytes(str(x), "ascii")).hexdigest(),_sage_const_16 )))

def padzero(binary, length):
	if (len(binary) >= length):
		return binary
	binary.insert(_sage_const_0 ,'0')
	return padzero(binary, length)

def convertBinary(binaryInt):
	print("start convert Binary")
	print(binaryInt)
	b = list(str(bin(binaryInt))[_sage_const_2 :])
	print(b)
	B = padzero(b, k2)
	B.reverse()
	print(B)
	return B

def genCaux():
	caux = {}
	for i in range(_sage_const_0 , l):
		caux["p"+str(i)] = [hash(encode(X[i]), _sage_const_0 ), hash(encode(X[i]), _sage_const_1 )]
	return caux

def Ii(i):
	return (IntPrime(_sage_const_0 )-int((Prime-_sage_const_1 )/_sage_const_2 **(((w-i)*L)+_sage_const_1 )),IntPrime(int((Prime-_sage_const_1 )/_sage_const_2 **(((w-i)*L)+_sage_const_1 ))))

def inRange(rangetup, hashval):
	if (rangetup[_sage_const_0 ] > rangetup[_sage_const_1 ]):
		if (hashval > rangetup[_sage_const_0 ] or hashval < rangetup[_sage_const_1 ]):
			return True
	if (rangetup[_sage_const_0 ] < rangetup[_sage_const_1 ]):
		if (hashval > rangetup[_sage_const_0 ] and hashval < rangetup[_sage_const_1 ]):
			return True
	return False

def join(a, b, level):
	print("RUn join")
	print(len(a))
	print(len(b))
	result = []
	for i in range(_sage_const_0 , len(a)):
		for j in range(_sage_const_0 , len(b)):
			ab = a[i][_sage_const_1 ]+b[j][_sage_const_1 ]  #todo modlus
			if (inRange(Ii(level), ab)):
				result.append((a[i][_sage_const_0 ]+b[j][_sage_const_0 ],ab,a[i][_sage_const_2 ]+b[j][_sage_const_2 ]))
				currentY = a[i][_sage_const_0 ]+b[j][_sage_const_0 ]
				sumY = _sage_const_0 
				for x in range(_sage_const_0 , len(currentY)):
					sumY += currentY[x]
				assert(sumY == ab)
				if (len(result) >= _sage_const_1024 ): 
					return result
	return result

caux = genCaux()

## Generate xi' 
xP = []
for i in range(_sage_const_0 ,l):
	a = X[i]-caux["p"+str(i)][_sage_const_0 ]
	b = caux["p"+str(i)][_sage_const_1 ] - caux["p"+str(i)][_sage_const_0 ]
	xP.append((a / b)) 

## Calculate First Term of RhoL
ft = _sage_const_0 
for i in range(_sage_const_0 , (k2-_sage_const_1 )+_sage_const_1 ): 
	ft += _sage_const_2 **i * xP[i]

## Calculate Mid Term of RhoL
a = Prime - _sage_const_1 
b = _sage_const_2 **((w+_sage_const_1 )*L+_sage_const_1 )
mt = IntPrime(int((a / b)))
print("mt")
print(mt)

## Calculate End Term of RhoL
et = _sage_const_0 
for i in range(k2, (k1+k2-_sage_const_1 )+_sage_const_1 ):
	et += X[i]

Pl = ft - mt - et
Cl = int(hash(encode(Pl)))
P.append(Pl)


# print(Ii(1))
# print(inRange(Ii(1), 10))
# print(inRange(Ii(1), 115792089237316195423570985008687907852837564279074904382605163141518161494337))



## Need a better definiton of this function
def kListHROS(w, L, P):
	#Setup ----
	print("start setup")
	aux = []
	for i in range(_sage_const_0 , _sage_const_2 **L):
		aux.append(i)
	print(aux)
	Liw = []
	for i in range(_sage_const_0 , len(P)):
		print("p"+str(i))
		Li = []
		for j in range(_sage_const_0 , len(aux)):
			Li.append(([IntPrime(hash(encode(P[i]), aux[j]))],IntPrime(hash(encode(P[i]), aux[j])),[aux[j]]))
		Liw.append(Li)
	Tree = [Liw]

	sourceFile = open('demo.txt', 'w')
	print(Tree, file = sourceFile)
	sourceFile.close()

	##Collison ----
	for x in range(_sage_const_0 , w): #add one because SUM is inclusive and end range is exclusive minus one because the range should be 1 - w
		print("level: "+str(x))
		FLi = []
		level = w-x
		TreeLevel = Tree[x]
		for j in range(_sage_const_0 , _sage_const_2 **(level-_sage_const_1 )): #add one because SUM is inclusive and end range is exclusive minus one because we are indexing from 0
			print("j"+(str(j)))
			FLi.append(join(TreeLevel[j*_sage_const_2 ],TreeLevel[_sage_const_2 *j+_sage_const_1 ],level)) #minus one because lists are 1 indexed in the paper
		Tree.append(FLi)
		
	finalTree = Tree[w][_sage_const_0 ]
	result = []
	for i in range(_sage_const_0 , len(finalTree)):
		if inRange(Ii(-_sage_const_1 ), finalTree[i][_sage_const_1 ]):
			result = (finalTree[i][_sage_const_0 ], finalTree[i][_sage_const_1 ], finalTree[i][_sage_const_2 ])
			break
		result = ([],_sage_const_0 ,[])
	return result

P2 = []
for i in range(_sage_const_0 , _sage_const_2 **w):
	P2.append(P[k2+i])



(y, s, auxk2l) = kListHROS(w, math.ceil(L), P2)

sumY = _sage_const_0 
for i in range(_sage_const_0 , len(y)):
	sumY += y[i]
assert(sumY == s)

smt = s + mt

B = convertBinary(smt)

Cib = []
auxi = []
for i in range(_sage_const_0 ,k2-_sage_const_1 +_sage_const_1 ):
	Cib.append(caux['p'+str(i)][int(B[i])])
	auxi.append(B[i])


C = []
for i in range(_sage_const_0 , k2-_sage_const_1 +_sage_const_1 ):
	C.append(Cib[i])

for i in range(_sage_const_0 , k1):
	C.append(y[i])
	# print("y["+str(i)+"] = "+str(y[i]))
	auxi.append(auxk2l[i])
if (k2 < l):
	auxi.append(auxk2l[k1])
else:
	auxi.append('aux321')

assert(y[k1] == int(hash(encode(Pl), auxi[l])))

for i in range(_sage_const_0 ,l-_sage_const_1 +_sage_const_1 ):
	assert(int(X[i](C)) == int(hash(encode(X[i]), auxi[i])))
	# print('p'+str(i)+" with varibal list above evaluates to: "+str(int(X[i](C)))+' and hashes to: '+str(int(hash(encode(X[i]), auxi[i])))+' with the aux value '+str(auxi[i]))
print("pL with varibal list above evaluates to: "+str(int(Pl(C)))+' and hashes to: '+str(int(hash(encode(Pl), auxi[l]))) +' with the aux value '+str(auxi[l]))

Cl = hash(encode(Pl), auxi[l])

sumXp = _sage_const_0 
for i in range(_sage_const_0 , k2):
	sumXp += _sage_const_2 **i * xP[i](C)

sumC = _sage_const_0 
for i in range(k2, l):
	sumC += X[i](C)

sumB = _sage_const_0 
for i in range(_sage_const_0 , k2):
	sumB += _sage_const_2 **i * int(B[i])
sumY = _sage_const_0 
for i in range(k2, l):
	sumY += y[i-k2]

assert(sumB == sumXp)
print(sumB)
print("".join(B))
print(s)
assert(sumB == s+mt)

print("1 = "+str(int(Pl(C))))
print("2 = "+str((sumXp - mt - sumC) % Prime))
print("3 = "+str((sumB - mt - sumY) % Prime))
print("4 = "+str((s - sumY) % Prime))
print("5 = "+str(int(hash(encode(Pl), auxi[l]))))
print("d = "+str(hash(encode(Pl), auxi[l]) - int(Pl(C))))
print("m = "+str(mt))
print("s = "+str(s))


Yval = _sage_const_0 
for i in range(_sage_const_0 , len(y)):
	Yval += y[i]
print("s - y  = "+str(s-Yval))

print(Ii(-_sage_const_1 ))


#              = 67335027711028348519148087300636081720158523555595798438729264680836696171822
#Cl            = 67335061525574109029746721603323635537974763533130538253132863068605048486494
#s + mt        = 67334976114994509657372820354118364484484835663119674732280079909222781096892
#Cl - (s + mt) = 67335061525524515770105222142291029771529647428223222804102787203170005642779
#s - mt        = 67335086136612356291202776805440409937262388740335668083631675309067603233376
#Cl - (s - mt) = 67335061525629828061773779328988947799213317860541724615452816245450413129850
#s             = 67335086136665012437037055398789368951104223956494918989306689830207806976911
#Cl - s        = 67335061525577171915939500735639988785371482644382473709777801724310209386314
#Cl + s        = 67335061525571046143553942471007282290578044421878602796487924412899887586673
#newCl         = 67335039924413049185070173788443570812405769538083078545009833255144324801299
#newCl - s     = 67335039924416112071262952920759924059802488649335014001654771910849485701120
#s - newCl     = 67335068133230453178142998795703522043490613099215197166492303415478769738865
#newCl - (s-mt)= 67335039924468768217097231514108883073644323865494264907329786431989689444655
#newCl - (s+mt)= 67335039924363455925428674327410965045960653433175763095979757389709281957584
		
                     # 55213970774324510299478046898216203619402677669084026519110280581244545
                

                # 115792034023345421099060685530641009636633944876397235298578644031237580249792







